#include "imports/stdlib.fc";

;; Operation codes
const op::create_htlc = 0x1;
const op::claim = 0x2;
const op::refund = 0x3;
const op::add_safety_deposit = 0x4;
const op::claim_safety_deposit = 0x5;

;; Error codes
const error::invalid_secret = 101;
const error::expired = 102;
const error::not_expired = 103;
const error::not_participant = 104;
const error::already_claimed = 105;
const error::already_refunded = 106;
const error::invalid_hash_length = 107;
const error::insufficient_amount = 108;
const error::htlc_not_found = 109;

;; Constants
const hash_length = 32; ;; SHA256 hash length
const min_timelock_duration = 3600; ;; 1 hour in seconds
const max_timelock_duration = 2592000; ;; 30 days in seconds

;; Storage structure
;; htlc_id:uint32 | next_htlc_id:uint32 | htlcs:dict

;; HTLC structure in dictionary:
;; sender:address | receiver:address | amount:coins | hashlock:bits256 | timelock:uint32 | 
;; secret:bits256 | claimed:bool | refunded:bool | created_at:uint32

() load_data() impure inline {
    ;; Data is loaded on demand within functions
}

() save_data(int next_htlc_id, cell htlcs) impure inline {
    set_data(begin_cell()
        .store_uint(next_htlc_id, 32)
        .store_dict(htlcs)
        .end_cell());
}

(int, cell) get_storage() inline {
    slice ds = get_data().begin_parse();
    return (ds~load_uint(32), ds~load_dict());
}

;; Create a new HTLC
() create_htlc(slice sender_address, int amount, slice receiver_address, int hashlock, int timelock) impure {
    ;; Validate inputs
    throw_unless(error::insufficient_amount, amount > 0);
    
    int current_time = now();
    throw_unless(error::invalid_hash_length, timelock > current_time + min_timelock_duration);
    throw_unless(error::invalid_hash_length, timelock <= current_time + max_timelock_duration);
    
    ;; Load storage
    (int next_htlc_id, cell htlcs) = get_storage();
    
    ;; Create HTLC entry
    builder htlc_data = begin_cell()
        .store_slice(sender_address)
        .store_slice(receiver_address)
        .store_coins(amount)
        .store_uint(hashlock, 256)
        .store_uint(timelock, 32)
        .store_uint(0, 256) ;; empty secret
        .store_uint(0, 1) ;; not claimed
        .store_uint(0, 1) ;; not refunded
        .store_uint(current_time, 32);
    
    ;; Store HTLC
    htlcs~udict_set(32, next_htlc_id, htlc_data.end_cell().begin_parse());
    
    ;; Save updated storage
    save_data(next_htlc_id + 1, htlcs);
}

;; Claim HTLC with secret
() claim_htlc(int htlc_id, slice secret_slice, slice claimer_address) impure {
    ;; Load storage
    (int next_htlc_id, cell htlcs) = get_storage();
    
    ;; Get HTLC
    (slice htlc_data, int found) = htlcs.udict_get?(32, htlc_id);
    throw_unless(error::htlc_not_found, found);
    
    ;; Parse HTLC data
    slice sender = htlc_data~load_msg_addr();
    slice receiver = htlc_data~load_msg_addr();
    int amount = htlc_data~load_coins();
    int hashlock = htlc_data~load_uint(256);
    int timelock = htlc_data~load_uint(32);
    int stored_secret = htlc_data~load_uint(256);
    int claimed = htlc_data~load_uint(1);
    int refunded = htlc_data~load_uint(1);
    int created_at = htlc_data~load_uint(32);
    
    ;; Validate claim
    throw_if(error::already_claimed, claimed);
    throw_if(error::already_refunded, refunded);
    throw_unless(error::not_participant, equal_slice_bits(receiver, claimer_address));
    throw_if(error::expired, now() >= timelock);
    
    ;; Verify secret - compute SHA256 hash for cross-chain compatibility
    ;; Hash the secret slice directly (raw 256 bits = 32 bytes)
    int secret_hash = string_hash(secret_slice);
    throw_unless(error::invalid_secret, secret_hash == hashlock);
    
    ;; Update HTLC as claimed
    builder updated_htlc = begin_cell()
        .store_slice(sender)
        .store_slice(receiver)
        .store_coins(amount)
        .store_uint(hashlock, 256)
        .store_uint(timelock, 32)
        .store_slice(secret_slice)
        .store_uint(1, 1) ;; claimed = true
        .store_uint(0, 1) ;; refunded = false
        .store_uint(created_at, 32);
    
    htlcs~udict_set(32, htlc_id, updated_htlc.end_cell().begin_parse());
    
    ;; Save updated storage
    save_data(next_htlc_id, htlcs);
    
    ;; Send funds to receiver
    var msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(receiver)
        .store_coins(amount)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .end_cell();
    send_raw_message(msg, 3);
}

;; Refund expired HTLC
() refund_htlc(int htlc_id, slice refunder_address) impure {
    ;; Load storage
    (int next_htlc_id, cell htlcs) = get_storage();
    
    ;; Get HTLC
    (slice htlc_data, int found) = htlcs.udict_get?(32, htlc_id);
    throw_unless(error::htlc_not_found, found);
    
    ;; Parse HTLC data
    slice sender = htlc_data~load_msg_addr();
    slice receiver = htlc_data~load_msg_addr();
    int amount = htlc_data~load_coins();
    int hashlock = htlc_data~load_uint(256);
    int timelock = htlc_data~load_uint(32);
    slice stored_secret = htlc_data~load_bits(256);
    int claimed = htlc_data~load_uint(1);
    int refunded = htlc_data~load_uint(1);
    int created_at = htlc_data~load_uint(32);
    
    ;; Validate refund
    throw_if(error::already_claimed, claimed);
    throw_if(error::already_refunded, refunded);
    throw_unless(error::not_participant, equal_slice_bits(sender, refunder_address));
    throw_unless(error::not_expired, now() >= timelock);
    
    ;; Update HTLC as refunded
    builder updated_htlc = begin_cell()
        .store_slice(sender)
        .store_slice(receiver)
        .store_coins(amount)
        .store_uint(hashlock, 256)
        .store_uint(timelock, 32)
        .store_slice(stored_secret)
        .store_uint(0, 1) ;; claimed = false
        .store_uint(1, 1) ;; refunded = true
        .store_uint(created_at, 32);
    
    htlcs~udict_set(32, htlc_id, updated_htlc.end_cell().begin_parse());
    
    ;; Save updated storage
    save_data(next_htlc_id, htlcs);
    
    ;; Send funds back to sender
    var msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(sender)
        .store_coins(amount)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .end_cell();
    send_raw_message(msg, 3);
}

;; Main message handler
() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        return ();
    }
    
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    if (flags & 1) { ;; ignore bounced messages
        return ();
    }
    
    slice sender_address = cs~load_msg_addr();
    
    int op = in_msg_body~load_uint(32);
    int query_id = in_msg_body~load_uint(64);
    
    if (op == op::create_htlc) {
        slice receiver_address = in_msg_body~load_msg_addr();
        int hashlock = in_msg_body~load_uint(256);
        int timelock = in_msg_body~load_uint(32);
        create_htlc(sender_address, msg_value, receiver_address, hashlock, timelock);
        return ();
    }
    
    if (op == op::claim) {
        int htlc_id = in_msg_body~load_uint(32);
        slice secret_slice = in_msg_body~load_bits(256);
        claim_htlc(htlc_id, secret_slice, sender_address);
        return ();
    }
    
    if (op == op::refund) {
        int htlc_id = in_msg_body~load_uint(32);
        refund_htlc(htlc_id, sender_address);
        return ();
    }
    
    throw(0xffff);
}

;; Get methods
(int, slice, slice, int, int, int, int, int, int, int) get_htlc(int htlc_id) method_id {
    (int next_htlc_id, cell htlcs) = get_storage();
    
    (slice htlc_data, int found) = htlcs.udict_get?(32, htlc_id);
    throw_unless(error::htlc_not_found, found);
    
    slice sender = htlc_data~load_msg_addr();
    slice receiver = htlc_data~load_msg_addr();
    int amount = htlc_data~load_coins();
    int hashlock = htlc_data~load_uint(256);
    int timelock = htlc_data~load_uint(32);
    slice secret_slice = htlc_data~load_bits(256);
    int claimed = htlc_data~load_uint(1);
    int refunded = htlc_data~load_uint(1);
    int created_at = htlc_data~load_uint(32);
    
    ;; Convert secret slice back to int for getter compatibility
    int secret = 0;
    repeat (32) {
        secret = (secret << 8) + secret_slice~load_uint(8);
    }
    
    return (htlc_id, sender, receiver, amount, hashlock, timelock, secret, claimed, refunded, created_at);
}

int get_next_htlc_id() method_id {
    (int next_htlc_id, _) = get_storage();
    return next_htlc_id;
}